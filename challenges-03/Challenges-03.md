# Ai Code Challenge #3 - Procedural Generation with Wave Function Collapse

## Goal

Use the Wave Function Collapse (WFC) algorithm to build a **procedural content generator** - with an LLM as your coding partner writing all the code. The aim is to create a tool that can take a small example pattern (or set of tiles) and automatically generate a large game level or texture that follows the same style and rules.

All coding should be done via AI assistance (no manual coding, only copy-paste is allowed) to explore how AI can help tackle a complex algorithm.

## What is Wave Function Collapse (WFC)?

WFC is a popular procedural generation technique that produces unique outputs (tilemaps, levels, images, etc.) based on a given input sample and a set of adjacency constraints. The algorithm was originally created by Maxim Gumin in 2016 and has since been implemented in many languages (including C++, Python, Rust, and more). It works by constraint solving: each cell in a grid is iteratively **collapsed** to a specific tile state, guided by rules of what neighboring tiles are allowed. The result is emergent patterns that resemble the input without outright copying it.

For instance, given a small input tileset or sample image, WFC can generate a much larger map that respects the sample's style and constraints. In the image below, WFC has taken a tiny tile sample and produced a full 2D map with coherent placement of terrain (grass, water, trees, etc.) without any obvious contradictions. This demonstrates how WFC can create endless variations of content while preserving logical adjacency rules - a powerful tool for game devs to quickly craft levels or textures.

<img src="https://github.com/mxgmn/WaveFunctionCollapse/raw/master/images/wfc.gif" alt="Wave Function Collapse" width="200" height="200"></img>

_Example output generated by a Wave Function Collapse algorithm - a larger tilemap created from a small input pattern. Each region of the map is filled in automatically by the algorithm following the adjacency rules of the sample._

## The Challenge

**Build a WFC-based procedural generator** that supports:

- **Input**: Define a small sample pattern or a set of tiles with adjacency rules. This could be as simple as a 2D array of characters/colors representing a mini-map, or a collection of tile images and a rule table of which tiles can neighbor each other.

- **Output**: Generate a larger grid (for example, a 64x64 tile map) that **never violates the input's adjacency rules**. The output should look like a plausible extension of the input pattern (no mismatched edges or impossible combinations).

- **Algorithm**: Implement the core WFC algorithm:

  - Represent the **wave** (the grid of output cells and their possible states).

  - Repeatedly **observe** (collapse) the cell with the fewest possibilities (lowest entropy) by choosing a tile for it, then **propagate** the constraints to neighboring cells, ruling out incompatible tiles.

  - If a contradiction arises (a cell ends up with zero possible tiles), handle it by eighter **backtracking** or restarting the generation.

- **Visualization**: Provide a way to **visualize the result**. This can be a simple text printout of the output grid (using symbols for different tiles), or a graphical window showing the generated map/image. Seeing the output is important for verifying that the WFC algorithm worked as expected.

- **Save or Display Result**: If possible, allow saving the generated output (e.g. output an image file or level file) or at least display it in a window. For game dev contexts, you might integrate the generated level into a simple game scene or editor for extra cool points.

**Feel free to get creative and make this challenge your own!** Since this is a freeform challenge, you can choose the theme or context of your generator.

## Rules

1. **Use an LLM as your coding partner** - let it write all the code for you, step by step or even entire files. You **should not write code manually**, the only thing you're allowed to do is copy & paste the AI-generated code into your project (and run it). Leverage the AI for everyting: scaffolding the project, implementing WFC logic, debugging, etc.

2. Use one of the provided AI coding assistants: for example **ChatGPT** or **Github Copilot** (feel free to try both). These AI tools are your pair-programmers. Ask them to generate code, explain complex concepts, or fix errors. The goal is to see how AI assistance can help build a non-trivial algorithm like WFC.

3. **Pick any programming language** you like (the challenge is language-agnotstic). If you're not sure, here are some popular choices for game dev and visualization:

- **C++**: You could use libraries like SFML or SDL2 to display tilemaps, or even just console output for text-based visualization.

- **Python**: A great beginner-friendly option - libraries like Pygame or PIL (Python Imaging Library) can help draw the output grid.

- **Rust**: Use game frameworks like ggez or Bevy, or visualization libs like SDL via bindings. Rust has WFC libraries too, but try to have the LLM write the logic to learn from it.

- **C# (Unity) / JavaScript / etc.**: Feel free to use Unity, Godot, Phaser.js, or any environment you're comfortable with. The important part is implementing WFC, not the specific language, so choose one that you can iterate quickly with the AI.

- _Note_: WFC has been implemented in many languages (C++, Python, Kotlin, Rust, JavaScript, and more), so whatever language you choose, the AI should be able to help with relevant examples.

4. **Ask for help constantly**. This is a complex algorithm - don't hesitate to query the LLM for every step. For example: "_How do I represent the tile adjacency rules in Python?_", "_Write the collapse function that picks the next cell with lowest entropy._", or "_Why is my propagation step not working? Help debug it._". Break the problem down and let the AI guide you. Remember, no human hard-coding - _think of the solution, then ask the AI to implement it_. If you get stuck on the theory, ask the AI to explain the WFC concept or suggest a plan.

5. **Focus on design and let the AI handle implementation**. Think like a game designer or level designer: decide what kind of content you want to generate and what rules it should follow, and let the LLM worry about turning those ideas into code. For instance, you might define that "water tiles shouldn't touch lava tiles" or "rooms should connect via doors" for a dungeon - describe these constraints to the AI and have it incorporate them into the code. This approach ensures you concentrate on the creative/technical _ideas_, while the AI handles the heavy lifting of coding them.

## Tips & Tricks

1. **Start small and build step-by-step**. WFC can be daunting, so begin with the simplest case: "_Set up a basic 5x5 grid with two tile types (A and B) and no invalid adjacencies_". Have the AI generate a minimal working example of a random fill. Then introduce the WFC constraints: "_Now add rules: A cannot be next to B horizontally._" Step by step, increase the complexity. This incremental approach helps both you and the AI verify each part before moving on.

2. **Use idiomatic code and data structures**. Ask the AI what the best way is to represent the problem in your chosen language. For example: "_What's an idiomatic way in Rust to store the set of possible tiles for each cell?_" or "_In Python, how can I efficiently represent adjacency rules? (Dict of tile -> allowed_neighbors?)_". This will help produce clean, understandable code. When the AI gives you code, feel free to ask for refactoring: "_Can you refactor this into a class structure with a Grid class?_" or "_Improve the readability of the collapse function._" Leveraging the AI's knowledge of best practices will make your solution more elegant and maintainable.

3. **Break the WFC algorithm into parts**. Don't ask for the entire solution in one go. Instead, tackle it in logical pieces and build up:

- _Data Setup_: Prompt the AI to define how tiles, constraints, and the grid (wave) are represented. Perhaps create a `Tile` class or use simple integers for tiles and a matrix for the grid.

- _Entropy & Observation_: Ask for a function to find the cell with the lowest entropy (the fewest possible tiles remaining) and collapse it (pick a tile randomly from its possibilities).

- _Propagation_: Next, have the AI write the function that propagates the consequences of that placement to neighboring cells (elliminating incompatible options from their possibility lists).

- _Backtracking (Optional initially)_: You can start without backtracking (maybe just restart the whole algorithm if it fails, for simplicity). Once the basic version works, ask the AI how to implement backtracking to handle contradictions more elegantly.

- _Visualization_: Finally, get the AI to help display the result - whether printing the grid to console or drawing it in a window. If using a library (like Pygame or SFML), you can ask things like "_How do I draw a 2D grid of colored tiles in Pygames?_" or "_Show me how to render my output matrix in a window._"

By breaking it down, you also make it easier to pinpoint issues. For example, after implementing propagation, test it (run the code) to see if constraints hold. If not, you can debug with the AI's help _before_ adding more complexity.

1. **Ask for scaffolding and boilerplate**. Don't waste time on trivial setup - let the AI do it. For example: "_Create a minimal project structure for a C++ SFML application._" or "_Write the boilerplate to initialize a Pygame window and loop_". Getting a basic game loop or image canvas up and running via AI will save you time. Similarly, if your language needs a build system (like CMake for C++ or Cargo for Rust), ask the AI to generate that configuration so you can focus on the WFC logic.

2. **Iterate, test, and refine**. Treat the AI as an interactive collaborator. Generate code, run it, and if (when) something doesn't work, show the error or describe the misbehavior to the LLM. For instance: "_My algorithm sometimes ends early and outputs an incomplete map. What could be wrong?_" or "_I got an index-out-of-range error in the propagation step - help me fix it_". The AI can suggest debugging steps or corrections. Use it to **optimize** as well: "_The generation is slow for a 50x50 grid; how can we speed it up?_" - it might suggest using more efficient data structures or algorithms. This back-and-forth is where you'll really see how AI coding assistance shines, especially for a complex task like this.

3. **Learn the theory with AI's help (if needed)**. If you're new to WFC, you can ask the LLM to explain the concept or even summarize resources. For example: "_Explain the Wave Function Collapse algorithm in simple terms_" or "_What are the differences between the overlapping model and the tiled model in WFC?_" Having this understanding will help when formulating your prompts and verifying the AI's output. Remember, the AI can help with **planning** too - you might prompt: "_Outline a step-by-step plan to implement WFC for a small tilemap._" Use these explanations to inform your coding strategy.

## Handy Resources

- **WFC Algorithm References**: If you want more background or get stuck, checkout the original WFC repository by [Maxim Gumin on GitHub](https://github.com/mxgmn/WaveFunctionCollapse).

## Bonus Points

Want to push the envelope? Try one of these **optional** enhancements for extra bragging rights:

- **Visual Flair**: Make the output really shine. For example, use a nicer tileset or sprite graphics for your generated level, add color and styling to your ASCII output, or even create an animation of the collapse process (showing the grid being filled in step by step). Visual creativity will make your project stand out.

- **Interactive Generation**: Add a way for a user to interact, such as placing a few initial tiles ("seeds") and then using WFC to fill in the rest, or allowing the user to regenerate new variations on the fly with a key press. This turns your generator into a little tool or toy that others can play with.

- **Advanced WFC Features**: Implement more complex aspects of the algorithm, like the overlapping model (where the input is an image and the algorithm extracts patterns automatically) instead of manually defined tiles. Or incorporate **backtracking** properly so the algorithm rarely fails even on difficult inputs. These add technical complexity and are a great test of the AI's ability to handle sophisticated logic.

- **Performance Improvements**: If you're feeling ambitious, try generating a really large output or running WFC multiple times quickly. This might involve optimizing the code (maybe the AI can help vectorize part of it, use multi-threading, etc.) It's a challenge to see how far you can push the AI-generated code in terms of efficiency.

Remember, bonus features are entirely optional - it's better to complete the core challenge and understand WFC with the AI's help than to overstretch. But if you have extra time or curiosity, these extensions can be very rewarding and educational. Good luck, have fun, and **happy collapsing**!
